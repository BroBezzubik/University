\section{Технологический раздел}
В данном разделе обоснован выбор инструментария. Рассписана реализация модуля ядра.
\subsection{Выбор инструментария}
\subsubsection{Язые программирования}
Был выбран язык С стандарта С11 для реализации программы, потому что:
\begin{enumerate}
	\item ядро написано на языке С.
	Что означает, что С полностью поддерживает все API ядра;
	\item на данный язык наибольшее количество литературы;
\end{enumerate}

\subsubsection{Среда разработки}
В качестве среды разработки мной был выбран Visual Studio Code.

Visual Studio Code - редактор исходного кода, разработанный Microsoft для Windows, Linux и macOS. Позиционируется как «лёгкий» редактор кода для кроссплатформенной разработки веб- и облачных приложений. Включает в себя отладчик, инструменты для работы с Git, подсветку синтаксиса, IntelliSense и средства для рефакторинга. Имеет широкие возможности для кастомизации: пользовательские темы, сочетания клавиш и файлы конфигурации. Распространяется бесплатно, разрабатывается как программное обеспечение с открытым исходным кодом, но готовые сборки распространяются под проприетарной лицензией.

\subsection{Реализация}
В данном подразделе рассмотрен makefile и загружаемый модуль ядра.
\subsubsection{Makefile}
Для облегчения изборки и избежания поторения одних и тех же команд был написан Makefile, который позволяет запускать сборку одной командой.

В листинге \ref{lst:makefile} представлено содержмое makefile.

\begin{lstlisting}[caption=Makefile, label=lst:makefile]
CFLAGS=-Wall

test: test.o

.PHONY: clean

clean:
-rm -f *~ *.o
\end{lstlisting}

Обратите внимание, что все команды должны выполняться к правами администратора или выполняться с командой sudo.

Для сборки модуля ядра необходимо выполнить команду make.
Для загрузки данного модуля в ядро, выполнять команду insdmod my\_vdev.ko.
Для выгрузки модуля из ядра, выполнять команду rmmod my\_vdev.

\subsubsection{Загружаемый модуль ядра}
Важная особенность реализации подсистемы устройств в OC Linux: драйвер оперирует с устройством как с парой номеров major/minor, a все команды GNU и функции POSIX API оперируют с устройством как с именем в каталоге /dev. 
Для работы с устройством мы должны установить взаимно однозначное соответствие между major/minor номерами и именем устройства. 
Для того чтобы задать такое соответствие используется макрос MKDEV.

Система сама может найти подходящий Cтарший номер, если вызывать функцию alloc\_chardev\_region.

Для инициализации структуры вызывается функция cdev\_init, которая содержит поле const struct file operations *ops, которое определяет доступные операции для работы с файлом.

Функция cdev\_add добавляет в структуру cdev зарегистрированный драйвер, структуру dev\_t.

Вызов фунции input\_allocate\_device инстанцирует структуру input\_dev, в
которой указывается какие события будут переданы устройству: EV\_REL, EV\_KEY, с помощью метода set\_bit.

При записи в файл, данные будут копироваться из из пользовательского пространства в пространство ядра с помощью вызова сору\_from\_user. 
Затем новые данные будут сохранены в struct my\_vdev.

Реализация обработчика прерываний на основе приведенного выше
алгоритма показана в листинге \ref{lst:kbd}

\lstinputlisting[caption=Листинг тестовой программы, firstline=128, label=lst:kbd, lastline=144]{src/code/my_vdev.c}

В тасклете сканкод в буфере будет проверен во всех случаях, и соответствующее событие мыши будет вызвано с помощью функций input\_report\_key, input\_report\_rel. 